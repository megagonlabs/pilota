#!/usr/bin/env python3
import argparse
import copy
import json
import os
import random
from enum import Enum
from logging import basicConfig, getLogger
from pathlib import Path
from typing import Optional, get_args

from asdc.schema.example import Example
from asdc.schema.id import SID, UttrID

from pilota.const.metachar import MARK_CONTEXT, NONE, PHRASE_SEP, SEP
from pilota.predict import Predictor
from pilota.schema import NAME, PilotaConfig, Request, ScorerConfig, Utterance
from pilota.scorer import CONFIG_FILE_NAME, LABEL_OK, get_scorer_input

logger = getLogger(__name__)


def sid2goldexs(
    path_original_list: list[Path],
) -> dict[SID, Example]:
    sid2goldex = {}
    for path_ex in path_original_list:
        for fname in sorted(path_ex.glob("*.jsonl")):
            with fname.open() as inf:
                for line in inf:
                    ex: Example = Example.parse_raw(line)
                    if ex.correct is None:
                        continue
                    sid2goldex[ex.sid] = ex
    return sid2goldex


class AutoGeneratedIncorrectFeature(Enum):
    luck = "luck"
    luck_partial = "luck_partial"
    unrelated = "unrelated"

    def __str__(self):
        return self.value


def ex2tsvline(ex: Example, pc: PilotaConfig, config: ScorerConfig) -> Optional[str]:
    if ex.correct is None:
        return

    sidx: int = ex.sid.sentence_num
    monologue_training = False
    if len(pc.acceptable_names) == 1:  # monologue
        monologue_training = True
        assert sidx == 0

    req = Request(
        context=[Utterance.parse_obj(v) for v in ex.context],
        sentences=[s for s in ex.sources],
    )
    _src: str = Predictor.get_inputs(
        request=req,
        pc=pc,
        monologue_training=monologue_training,
    )[sidx]

    _tgt: str = NONE
    if len(ex.targets) > 0:
        _tgt = SEP.join(ex.targets)
    assert len(_tgt) > 0

    _src = Predictor.normalize(_src)
    _tgt = Predictor.normalize(_tgt)
    assert "\t" not in _src
    assert "\t" not in _tgt
    si: str = get_scorer_input(
        src=_src,
        target=_tgt,
        context_separator=config.context_separator,
    )

    vals = [LABEL_OK]
    if not ex.correct:
        if ex.example_types is None:  # Skip unknown incorrect
            return None
        vals = ex.example_types
    return f"{ex.sid.id}\t{si}" + "\t" + json.dumps(vals) + "\n"


def get_auto_generated_incorrect_luck(ex: Example) -> Optional[Example]:
    assert ex.correct is True
    new_ex: Example = copy.deepcopy(ex)
    new_ex.sid.id = "auto_err_luck." + ex.sid.id
    new_ex.correct = False
    new_ex.example_types = ["lack"]

    if not (2 <= len(new_ex.targets) <= 3):
        return

    idx: int = random.randint(0, len(new_ex.targets) - 1)
    del new_ex.targets[idx]
    return new_ex


def get_auto_generated_incorrect_luck_partial(ex: Example) -> Optional[Example]:
    assert ex.correct is True
    if len(ex.targets) == 0:
        return
    if len(ex.targets) > 2:
        return

    new_ex: Example = copy.deepcopy(ex)
    new_ex.sid.id = "auto_err_luck_partial." + ex.sid.id
    new_ex.correct = False
    new_ex.example_types = ["lack"]

    for j, t in enumerate(new_ex.targets):
        if PHRASE_SEP in t:
            tmp = t.split(PHRASE_SEP)
            idx: int = random.randint(0, len(tmp) - 1)
            del tmp[idx]
            new_ex.targets[j] = PHRASE_SEP.join(tmp)
            break
    else:
        return
    return new_ex


def get_incorrect_none(ex: Example) -> Optional[Example]:
    assert ex.correct is True
    if len(ex.targets) == 0:
        return
    ex_err_none: Example = copy.deepcopy(ex)
    ex_err_none.targets = []
    ex_err_none.sid.id = "auto_err_none." + ex_err_none.sid.id
    ex_err_none.correct = False
    ex_err_none.example_types = ["incorrect_none"]
    return ex_err_none


def get_auto_generated_incorrect_unrelated_ex(
    ex: Example,
    uttrid2goldexs: dict[UttrID, list[Example]],
) -> Optional[Example]:
    assert ex.correct is True
    p: int = ex.sid.uttrid.num - 1

    # Find prev examples
    while p >= 0:
        p -= 1
        key = UttrID(id=ex.sid.docid.id + f".{p}")
        goldexs = uttrid2goldexs.get(key)
        if goldexs is not None:
            break
    else:
        return

    last_scud: str
    for gex in reversed(goldexs):
        if len(gex.targets) > 0:
            last_scud = gex.targets[-1]
            break
    else:
        return

    if last_scud in ex.targets:
        return

    ex_err_unrelated: Example = copy.deepcopy(ex)
    ex_err_unrelated.sid.id = "auto_err_unrelated." + ex_err_unrelated.sid.id
    ex_err_unrelated.targets.append(last_scud)
    ex_err_unrelated.correct = False
    ex_err_unrelated.example_types = ["limited"]
    return ex_err_unrelated


class MyWriter:
    def __init__(self, path_out: Path, config: ScorerConfig):
        self._p2f = {}
        for t in {"test", "dev", "train"}:
            self._p2f[t] = path_out.joinpath(f"{t}.tsv").open("w")

        self.labels = set()
        self.config = config

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        for v in self._p2f.values():
            v.close()

    def write(self, ex: Optional[Example], pc: PilotaConfig):
        if ex is None:
            return
        outf = self._p2f[ex.purpose]
        v = ex2tsvline(ex, pc, self.config)

        if ex.example_types is not None:
            for ext in ex.example_types:
                self.labels.add(ext)
        self.labels.add(LABEL_OK)

        if v is None:
            return
        outf.write(v)


def operation(
    path_in_dir_list: list[Path],
    path_original_list: list[Path],
    path_out: Path,
    context: int,
    names: list[str],
    extras: set[str],
    config: ScorerConfig,
) -> None:
    assert len(names) > 0
    path_out.mkdir(exist_ok=True, parents=True)

    pc = PilotaConfig(
        size_context=context,
        acceptable_names=names,
    )
    sid2goldex: dict[SID, Example] = sid2goldexs(path_original_list)
    logger.info(f"# of sentences (examples): {len(sid2goldex):,}")

    uttrid2goldexs: dict[UttrID, list[Example]] = {}
    for sid, ex in sid2goldex.items():
        assert ex.correct is None or ex.correct is True
        uttrid = sid.uttrid
        if uttrid not in uttrid2goldexs:
            uttrid2goldexs[uttrid] = []
        uttrid2goldexs[uttrid].append(ex)
    logger.info(f"# of utterances: {len(uttrid2goldexs):,}")

    done_sids: set[SID] = set()
    with MyWriter(path_out, config) as w:
        count_labeled: int = 0
        count_added_orig: int = 0
        for path_in_dir in path_in_dir_list:
            assert path_in_dir.is_dir()
            for path_in in path_in_dir.glob("*.jsonl"):
                with path_in.open() as inf:
                    for line in inf:
                        # Add annotated examples
                        ex: Example = Example.parse_raw(line)
                        if ex.correct is None:
                            continue
                        assert isinstance(ex.correct, bool)
                        w.write(ex, pc)
                        count_labeled += 1

                        # Add an original example as a correct example
                        oid = ex.original_sid
                        if oid is None:
                            continue
                        done_sids.add(oid)
                        orig_ex = sid2goldex.get(oid)
                        if orig_ex is not None:
                            w.write(orig_ex, pc)
                            count_added_orig += 1
        logger.info(f"Added examples from annotations: {count_labeled:,}")
        logger.info(f"Added correct examples from golds: {count_added_orig:,}")

        # Add correct (gold) examples whose target = <none>
        count_correct_none_examples: int = 0
        for sid, ex in sid2goldex.items():
            if len(ex.targets) == 0:
                done_sids.add(sid)
                w.write(ex, pc)
                count_correct_none_examples += 1
        logger.info(f"Added correct examples whose targets are NONE: {count_correct_none_examples:,}")

        count_incorrect_none_exs: int = 0
        count_incorrect_luck: int = 0
        count_incorrect_luck_partial: int = 0
        count_incorrect_unrelated: int = 0
        for sid, ex in sorted(sid2goldex.items(), key=lambda _: random.random()):
            if (incorrect_none_ex := get_incorrect_none(ex)) is not None:
                if count_incorrect_none_exs < count_correct_none_examples:
                    w.write(incorrect_none_ex, pc)
                    count_incorrect_none_exs += 1
                elif len(extras) == 0:
                    break

            if AutoGeneratedIncorrectFeature.luck.value in extras:
                if (luck_ex := get_auto_generated_incorrect_luck(ex)) is not None:
                    w.write(luck_ex, pc)
                    count_incorrect_luck += 1

            if AutoGeneratedIncorrectFeature.luck_partial.value in extras:
                if (luck_ex_p := get_auto_generated_incorrect_luck_partial(ex)) is not None:
                    w.write(luck_ex_p, pc)
                    count_incorrect_luck_partial += 1

            if AutoGeneratedIncorrectFeature.unrelated.value in extras:
                if (extra_ex := get_auto_generated_incorrect_unrelated_ex(ex, uttrid2goldexs)) is not None:
                    w.write(extra_ex, pc)
                    count_incorrect_unrelated += 1

        logger.info(f"Added incorrect auto generated examples whose targets are NONE: {count_incorrect_none_exs:,}")
        logger.info(f"Extra flags for auto generation: {extras}")
        logger.info(f"  Added incorrect auto generated examples (luck): {count_incorrect_luck:,}")
        logger.info(f"  Added incorrect auto generated examples (luck_partial): {count_incorrect_luck_partial:,}")
        logger.info(f"  Added incorrect auto generated examples (unrelated): {count_incorrect_unrelated:,}")

        with path_out.joinpath("labels.txt").open("w") as outf_label:
            for label in sorted(list(w.labels)):
                outf_label.write(f"{label}\n")


def get_opts() -> argparse.Namespace:
    oparser = argparse.ArgumentParser()
    oparser.add_argument("--input", "-i", action="append", type=Path, required=True)
    oparser.add_argument("--output", "-o", type=Path, required=True)
    oparser.add_argument("--original", action="append", type=Path, required=True)
    oparser.add_argument("--context", type=int, required=True)
    oparser.add_argument("--context_separator", default=MARK_CONTEXT)
    oparser.add_argument("--name", action="append", required=True, choices=get_args(NAME))
    oparser.add_argument(
        "--extra",
        choices=[v.value for v in AutoGeneratedIncorrectFeature] + ["all"],
        action="append",
        default=[],
    )
    return oparser.parse_args()


def main() -> None:
    opts = get_opts()
    random.seed(42)
    basicConfig(
        level=os.getenv("LOG_LEVEL", "INFO"),
        format="[%(asctime)s] %(module)s.%(funcName)s:%(lineno)d %(levelname)s -> %(message)s",
    )

    extras = set(opts.extra)
    if "all" in extras:
        extras = set([v.value for v in AutoGeneratedIncorrectFeature])
    else:
        for v in extras:
            assert v in {v.value for v in AutoGeneratedIncorrectFeature}

    config = ScorerConfig(
        context_separator=opts.context_separator,
    )
    opts.output.mkdir(exist_ok=True, parents=True)
    with opts.output.joinpath(CONFIG_FILE_NAME).open("w") as outf:
        outf.write(
            config.model_dump_json(
                indent=4,
            )
        )
        outf.write("\n")

    operation(
        opts.input,
        opts.original,
        opts.output,
        opts.context,
        opts.name,
        extras,
        config,
    )


if __name__ == "__main__":
    main()
